# myNote

## 实用工具

## 1、CSS相关

### 1.1 实现淡入淡出、透明度、过度

### 1.2 svg中text标签基础使用

### 1.3 HTML跳转到页面指定位置的几种方法

#### 1.3.1 利用 id 为标记的锚点，这里作为锚点的标签可以是任意元素。

#### 1.3.2 利用 a 标签的 name 属性作为锚点，这里作为锚点的标签只能是 a 标签。

#### 1.3.3 利用 scrollTo()，window.scrollTo 滚动到文档中的某个坐标。

#### 1.3.4 利用 scrollIntoView()，Element.scrollIntoView() 方法让当前的元素滚动到浏览器窗口的可视区域内。

#### 1.3.5 利用 scrollIntoView()，跳转到指定页面的指定位置。

### 1.4 实现回到页面顶部功能

#### 1.4.1 使用锚点实现

### 1.4.2 scrollTo函数

### 1.4.3 scrollTop函数

### 1.4.4 scrollBy函数

### 1.4.4 间接回到顶部

### 1.5 鼠标悬停时显示元素

### 1.6 CSS实现自动换行、强制换行、强制不换行的属性

### 1.7 实用的CSS background-image小技巧

#### 1.7.1 将背景图完美适配视口

#### 1.7.2 在CSS中使用多个背景图

#### 1.7.3 创建三角背景图

#### 1.7.4 在背景图上添加叠加渐变

#### 1.7.5 创建变色背景图动画

#### 1.7.6 制作网格背景图

#### 1.7.7 将背景图设置为文本填充

### 1.8 图解 e.clientX,e.clientY e.pageX e.pageY e.offsetX e.offsetY

### 1.9 按钮Button、图标Svg等点击之后出现黑框的原因及解决办法

### 1.10 flex布局

#### 容器的属性：

#### 1.10.1 flex-direction属性

#### 1.10.2 flex-wrap属性

#### 1.10.3 flex-flow属性

#### 1.10.4 justify-content属性

#### 1.10.5 align-items属性

#### 1.10.6 align-content属性

#### 项目的属性：

#### 1.10.7 order属性

#### 1.10.8 flex-grow属性

#### 1.10.9  flex-shrink属性

#### 1.10.10  flex-basis属性

#### 1.10.11  flex属性

#### 1.10.12  align-self属性

### 1.11 Vue移动端 / PC端适配解决方案：postcss-px-to-viewport

#### 1.11.1 开发环境`npm`安装插件

#### 1.11.2 项目根目录添加配置文件 postcss.config.js

#### 1.11.3 添加配置

#### 1.11.4 重新运行项目，触发配置文件生效

### 1.12 标准盒模型和怪异盒子模型的区别

#### 1.12.1 标准盒模型

#### 1.12.1 怪异盒模型

### 1.13 获取浏览器可视区域的宽度和高度

## 2、JavaScript相关

### 2.1 获取图片实际宽高

### 2.2 JavaScript中封装手机触屏判断滑动方向和滑动距离

### 2.3 函数节流和函数防抖及其区别

#### 2.3.1 函数节流

#### 2.3.2 函数防抖

### 2.4 JavaScript删除对象属性及判定是否包含某属性

#### 2.4.1 删除对象属性

##### 2.4.1.1 delete

##### 2.4.1.2 ES6解构赋值

##### 2.4.1.3 ES6反射

#### 2.4.2 对象是否包含某属性

##### 2.4.2.1 delete

##### 2.4.2.2 属性判断

##### 2.4.2.3 Object.keys

##### 2.4.2.4 ES6属性名in对象

### 2.5 forEach和map的区别

### 2.6 JavaScript 中使用媒体查询

### 2.7 从生成器函数Generator角度思考async await

#### 2.7.1 Generator函数基础

#### 2.7.2 Generator函数返回值

#### 2.7.3 Generator函数中的return

#### 2.7.4 Generator函数异步解决方案

#### 2.7.5 总结

## 3、HTML5相关

### 3.1 HTML5触摸事件

#### 3.1.1 触摸事件基础

#### 3.1.2 使用场景示例

### 3.2 IntersectionObserver使用

#### 3.2.1 IntersectionObserver基础

#### 3.2.2 IntersectionObserverEntry对象

#### 3.2.3 使用场景示例

##### 3.2.3.1 惰性加载（lazy load）

##### 3.2.3.2 无限滚动

### 3.3 Canvas学习

#### 3.3.1 Canvas基本用法

##### 3.3.1.1 Canvas元素

##### 3.3.1.2 渲染上下文（The rendering context）

#### 3.3.2 使用Canvas来绘制图形

##### 3.3.2.1 栅格（canvas grid）

##### 3.3.2.2 绘制矩形

##### 3.3.2.3 绘制路径

###### 3.3.2.3.1 绘制一个三角形

###### 3.3.2.3.2 移动笔触

###### 3.3.2.3.3 线

###### 3.3.2.3.4 圆弧

###### 3.3.2.3.5 二次贝塞尔曲线及三次贝塞尔曲线

###### 3.3.2.3.6 矩形

###### 3.3.2.3.7 组合使用

##### 3.3.2.4 Path2D对象

#### 3.3.3 应用样式和色彩

##### 3.3.3.1 色彩

##### 3.3.3.2 透明度

##### 3.3.3.3 线型

##### 3.3.3.4 渐变

##### 3.3.3.5 图案样式（Patterns）

##### 3.3.3.6 阴影

##### 3.3.3.7 Canvas填充规则

#### 3.3.4 绘制文本

##### 3.3.4.1 绘制文本

##### 3.3.4.2 有样式的文本

##### 3.3.4.3 预测量文本宽度

##### 3.3.4.4 Geoko 特性说明

#### 3.3.5 使用图像

##### 3.3.5.1 获得需要绘制的图片

##### 3.3.5.2 绘制图片

##### 3.3.5.3 缩放

##### 3.3.5.4 切片

##### 3.3.5.5 画廊示例

##### 3.3.5.6 控制图像的缩放行为

#### 3.3.6 变形（Transformations）

##### 3.3.6.1 状态的保存和恢复

##### 3.3.6.2 移动

##### 3.3.6.3 旋转

##### 3.3.6.4 缩放

##### 3.3.6.5 变形

#### 3.3.7 合成（Compositing）

##### 3.3.7.1 全局合成操作

##### 3.3.7.2 裁切路径

#### 3.3.8 基本动画

##### 3.3.8.1 动画的基本步骤

##### 3.3.8.2 操控动画

##### 3.3.8.3 动画示例

#### 3.3.9 高级动画

##### 3.3.9.1 绘制小球

##### 3.3.9.2 添加速率

##### 3.3.9.3 边界

##### 3.3.9.4 加速度

##### 3.3.9.5 长尾效果

##### 3.3.9.6 添加鼠标控制

#### 3.3.10 像素操作

##### 3.3.10.1 ImageData对象

##### 3.3.10.2 创建ImageData对象

##### 3.3.10.3 获取场景像素数据

##### 3.3.10.4 在场景中写入像素数据

##### 3.3.10.5 缩放和抗锯齿

##### 3.3.10.6 保存图片

#### 3.3.11 canvas 的优化

##### 3.3.11.1 在离屏Canvas上预渲染相似的图形或重复的对象

##### 3.3.11.2 避免浮点数的坐标点，用整数取而代之

##### 3.3.11.3 使用drawImage时不要缩放图像

##### 3.3.11.4 将复杂的场景分解为多层画布

##### 3.3.11.5 用CSS设置大的背景图

##### 3.3.11.6 用CSS变换特性缩放画布

##### 3.3.11.7 关闭透明度

##### 3.3.11.8 更多建议

### 3.4 SVG学习

#### 3.4.1 SVG基础

##### 3.4.1.1 基本要素

##### 3.4.1.2 SVG兼容性

##### 3.4.1.3 SVG的种类

##### 3.4.1.4 SVG基础示例

##### 3.4.1.5 SVG基础属性

##### 3.4.1.6 SVG文件类型

##### 3.4.1.7 Web服务器使用SVG文件

#### 3.4.2 使用SVG来绘制图形

##### 3.4.2.1 网格坐标定位

##### 3.4.2.2 绘制矩形

##### 3.4.2.3 绘制圆形

##### 3.4.2.4 绘制椭圆

##### 3.4.2.5 绘制线条

##### 3.4.2.6 绘制折线

##### 3.4.2.7 绘制多边形

##### 3.4.2.8 绘制路径

#### 3.4.3 路径

##### 3.4.3.1 直线命令

###### 3.4.3.1.1 `Move to`命令

###### 3.4.3.1.2 `Line to`命令

###### 3.4.3.1.3 `Horizontal lineto`命令

###### 3.4.3.1.4 `Vertical lineto`命令

###### 3.4.3.1.5 `Closepath`命令

###### 3.4.3.1.6 矩形示例

##### 3.4.3.2 曲线命令

###### 3.4.3.2.1 `Cubic Bezier Curve`命令

###### 3.4.3.2.2 二次贝塞尔曲线命令

###### 3.4.3.2.3 弧形命令

#### 3.4.4 填充和描边

##### 3.4.4.1 填充

##### 3.4.4.2 描边

##### 3.4.4.3 使用CSS设置样式

#### 3.4.5 渐变

##### 3.4.5.1 线性渐变

##### 3.4.5.2 径向渐变

#### 3.4.6 图案

##### 3.4.6.1 图案

##### 3.4.6.2 嵌入光栅图像

##### 3.4.6.3 嵌入XML

#### 3.4.7 文本

##### 3.4.7.1 text元素

##### 3.4.7.2 tspan元素

##### 3.4.7.3 textPath元素

##### 3.4.7.4 SVG字体

#### 3.4.8 基础变形

##### 3.4.8.1 平移

##### 3.4.8.2 旋转

##### 3.4.8.3 斜切

##### 3.4.8.4 缩放

##### 3.4.8.5 矩阵操作

##### 3.4.8.6 坐标系统上的变形

##### 3.4.8.7 SVG嵌套变形

#### 3.4.9 裁切和遮罩

##### 3.4.9.1 裁切

##### 3.4.9.2 遮罩

##### 3.4.9.3 透明度

#### 3.4.10 滤镜效果

### 3.5 Blob及File学习

#### 3.5.1 Blob对象

##### 3.5.1.1 语法

##### 3.5.1.2 属性

##### 3.5.1.3 实例方法

##### 3.5.1.4 使用场景

#### 3.5.2 File对象

##### 3.5.2.1 语法

##### 3.5.2.2 属性

##### 3.5.2.3 实例方法

##### 3.5.2.4 获取方式

##### 3.5.2.5 支持Blob和File对象的API

#### 3.5.3 FileReader对象

##### 3.5.3.1 语法

##### 3.5.3.2 属性

##### 3.5.3.3 实例方法

##### 3.5.3.4 事件

#### 3.5.4 Base64编码

##### 3.5.4.1 Base64编码原理

##### 3.5.4.2 Base64编码转换

#### 3.5.5 URL.createObjectURL()静态方法

##### 3.5.4.1 语法

##### 3.5.4.2 内存管理

##### 3.5.5.3 使用场景

### 3.6 WebSocket学习

#### 3.6.1 WebSocket的生命周期

#### 3.6.2 数据帧格式

#### 3.6.3 WebSocket的API

##### 3.6.3.1 语法

##### 3.6.3.2 属性

##### 3.6.3.3 实例方法

##### 3.6.3.4 事件

##### 3.6.3.5 示例

#### 3.6.4 数据传递

##### 3.6.4.1 数据分片

##### 3.6.4.2 数据分片例子

#### 3.6.5 保持连接

##### 3.6.5.1 实现方式

##### 3.6.5.2 心跳

#### 3.6.6 WebSocket性能

##### 3.6.6.1 WebSocket的优势和劣势

##### 3.6.6.2 WebSocket与传统HTTP请求/响应模型比较

##### 3.6.6.3 WebSocket性能优化

## 4、VUE2相关

## 5、VUE3相关

### 5.1 子组件修改父组件props值

### 5.2 自定义Hooks

### 5.3 computed计算属性传参

### 5.4 useId的使用

#### 5.4.1 useId概念

#### 5.4.2 实现原理

#### 5.4.3 使用场景

##### 5.4.3.1 表单元素的唯一标识

##### 5.4.3.2 列表渲染中的唯一键

##### 5.4.3.3 服务端渲染（SSR）中避免ID冲突

##### 5.4.3.4 组件库中的ID生成

### 5.5 ref和reactive的区别

#### 5.5.1 ref函数

##### 5.5.1.1 ref使用

##### 5.5.1.2 ref在模板中的使用

##### 5.5.1.3 为什么要使用ref

##### 5.5.1.4 深层响应性

##### 5.5.1.5 DOM 更新时机

#### 5.5.2 reactive函数

##### 5.5.2.1 reactive使用

##### 5.5.2.2 reactive在模板中的使用

##### 5.5.2.3 reactive的代理对象与原始对象的区别

#### 5.5.3 reactive的局限性

##### 5.5.3.1 有限的值类型

##### 5.5.3.2 不能替换整个对象

##### 5.5.3.3 对解构操作不友好

#### 5.5.4 reactive与ref对比图

### 5.6 useTemplateRef使用

#### 5.6.1 useTemplateRef是什么

#### 5.6.2 ref模版引用的问题

#### 5.6.3 useTemplateRef函数

#### 5.6.4 hooks中使用useTemplateRef函数

#### 5.6.5 useTemplateRef源码

## 6、Git相关

## 7、GitHub相关

## 8、NPM相关

## 9、项目相关

## 10、性能优化相关

## 11、Visual Studio Code配置相关

## 12、WebStorm配置相关

## 13、webpack相关

## 14、Vite相关
