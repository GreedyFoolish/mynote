# 垃圾回收策略

**垃圾回收**（`Garbage Collection`, `GC`）是编程语言中用于自动管理内存的技术，确保不再使用的内存可以被回收并重新分配给新的对象。
不同的编程语言和运行时环境可能使用不同的垃圾回收策略。以下是几种常见的垃圾回收策略，包括引用计数`Reference Counting`和其他策略：

## 1. 引用计数（Reference Counting）

* **原理**：每个对象都有一个计数器，记录有多少个引用指向该对象。当计数器为零时，表示没有任何引用指向该对象，此时可以安全地回收该对象的内存。
* **优点**：
    * 实现简单。
    * 实时性好，内存可以立即回收。
* **缺点**：
    * 无法处理循环引用问题。例如，两个对象互相引用，即使它们不再被程序使用，计数器也不会降为零。
    * 每次引用或解除引用都需要更新计数器，可能会影响性能。

## 2. 标记-清除（Mark-Sweep）

* **原理**：
    * **标记阶段**：从根对象（如全局变量）开始，遍历所有可达对象，并标记这些对象。
    * **清除阶段**：遍历整个堆内存，回收所有未被标记的对象。
* **优点**：
    * 能够处理循环引用问题。
    * 实现相对简单。
* **缺点**：
    * 需要暂停程序执行（`Stop-the-World`），可能会影响性能。
    * 可能会产生内存碎片。

## 3. 复制（Copying）

* **原理**：
    * 将堆内存分成两个相等的部分（通常是新生代和老年代）。
    * 新对象分配在其中一个部分（通常是新生代）。
    * 当新生代空间不足时，执行垃圾回收，将所有存活的对象复制到另一个部分。
    * 清空原部分，释放内存。
* **优点**：
    * 减少内存碎片。
    * 实现简单。
* **缺点**：
    * 需要额外的空间来存储复制的对象。
    * 可能需要暂停程序执行。

## 4. 标记-整理（Mark-Compact）

* **原理**：
    * 标记阶段与标记-清除相同，标记所有可达对象。
    * 整理阶段将所有存活的对象移动到堆内存的一端，形成连续的内存块，然后清除剩余的空间。
* **优点**：
    * 减少内存碎片。
    * 避免了复制对象的开销。
* **缺点**：
    * 需要暂停程序执行。
    * 整理过程可能比较耗时。

## 5. 分代收集（Generational Collection）

* **原理**：
    * 将堆内存分成多个代（通常是新生代和老年代）。
    * 新对象分配在新生代。
    * 新生代空间不足时，执行垃圾回收，存活的对象晋升到老年代。
    * 老年代的对象通常更稳定，因此垃圾回收频率较低。
* **优点**：
    * 提高了垃圾回收的效率，因为大多数对象在短时间内就会被回收。
* **缺点**：
    * 实现相对复杂。
    * 需要管理多个代。

## 6. 增量收集（Incremental Collection）

* **原理**：
    * 将垃圾回收过程分成多个小步骤，分散到程序的执行过程中，减少对程序性能的影响。
* **优点**：
    * 减少了暂停程序执行的时间。
* **缺点**：
    * 实现复杂，可能会影响垃圾回收的效率。

## 7. 并行收集（Parallel Collection）

* **原理**：
    * 利用多核处理器，将垃圾回收过程并行化，提高回收速度。
* **优点**：
    * 提高了垃圾回收的效率。
* **缺点**：
    * 实现复杂，需要协调多个线程。

## 8. 并发收集（Concurrent Collection）

* **原理**：
    * 垃圾回收过程与程序的执行并发进行，减少对程序性能的影响。
* **优点**：
    * 减少了暂停程序执行的时间。
* **缺点**：
    * 实现复杂，需要协调垃圾回收线程和应用程序线程。

## 9. 分区收集（Region-Based Collection）

* **原理**：
    * 将堆内存分成多个固定大小的区域（`Region`），每个区域独立管理。
* **优点**：
    * 提高了垃圾回收的局部性，减少了内存碎片。
* **缺点**：
    * 实现复杂，需要管理多个区域。

## 10. 三色标记（Tri-color Marking）

* **原理**：
    * 使用三种颜色（白色、灰色、黑色）来标记对象：
        * 白色：未访问的对象。
        * 灰色：正在访问的对象。
        * 黑色：已访问的对象。
    * 从根对象开始，将所有可达对象标记为灰色，然后将灰色对象标记为黑色，并将其引用的对象标记为灰色，重复此过程直到没有灰色对象为止。
* **优点**：
    * 适用于并发垃圾回收。
* **缺点**：
    * 实现复杂，需要管理对象的颜色状态。

## 11. 空间压缩（Space Compaction）

* **原理**：
    * 在标记-清除或标记-整理过程中，将存活的对象移动到堆内存的一端，形成连续的内存块，然后清除剩余的空间。
* **优点**：
    * 减少内存碎片。
* **缺点**：
    * 需要暂停程序执行。

## 12. 分区分配（Partition Allocation）

* **原理**：
    * 将堆内存分成多个分区，每个分区用于存储特定大小的对象。
* **优点**：
    * 提高了分配和回收的效率。
* **缺点**：
    * 实现复杂，需要管理多个分区。

## 13. 栈分配（Stack Allocation）

* **原理**：
    * 将对象分配在栈上，而不是堆上。
* **优点**：
    * 分配和回收非常高效。
* **缺点**：
    * 适用于生命周期短暂的对象。
    * 栈空间有限。

## 14. 引用计数与标记-清除结合

* **原理**：
    * 结合引用计数和标记-清除的优点，使用引用计数来快速回收大多数对象，使用标记-清除来处理循环引用问题。
* **优点**：
    * 结合了两种策略的优点。
* **缺点**：
    * 实现复杂。

## 15. 引用计数与分代收集结合

* **原理**：
    * 结合引用计数和分代收集的优点，使用引用计数来快速回收大多数对象，使用分代收集来处理老年代的对象。
* **优点**：
    * 结合了两种策略的优点。
* **缺点**：
    * 实现复杂。

## 总结

不同的垃圾回收策略适用于不同的应用场景。`JavaScript`引擎（如`V8`）通常使用分代收集和标记-整理的结合策略，
以平衡性能和内存管理的需求。了解这些策略有助于更好地理解和优化内存管理，避免内存泄漏等问题。
